# Chap3. 코드에서 나는 악취(2)

# 3.13 반복문

일급 함수를 지원하는 언어가 많아졌기 때문에 **반복문을 파이프라인**(filter, map..)**으로 바꾸기**(8.8절)를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.

# 3.14 성의 없는 요소

리팩토링을 거치면서 역할이 줄어든 프로그램 요소는 **함수 인라인**하기(6.2), **클래스 인라인**하기(7.6)로 처리한다. 상속을 사용했다면 **계층 합치기**(12.9)를 적용한다.

> 프로그램 요소: 프로그래밍 언어가 제공하는 함수, 클래스, 인터페이스 등 코드 구조를 잡는 데 활용되는 요소

# 3.15 추측성 일반화

당장 걸리적거리는 코드는 눈앞에서 치워버리자. 

하는 일이 거의 없는 추상 클래스는 계층 합치기(12.9)로 제거한다. 쓸데없이 위임하는 코드는 함수 인라인하기(6.2)나 클래스 인라인하기(7.6)로 삭제한다. 본문에서 사용되지 않는 매개변수는 함수 선언하기(6.5)로 없앤다.

추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있다. 이런 코드는 테스트 코드 삭제 후 죽은 코드 제거하기(8.9)로 삭제한다.

# 3.16 임시 필드

특정 상황에서만 값이 설정되는 필드를 가진 클래스는 클래스 추출하기(7.5)로 제 살 곳을 찾아준다. 그런 다음 함수 옮기기(8.2)로 임시 필드와 관련된 코드를 모조리 새 클래스에 몰아넣는다. 

또한 임시 필드들이 유효한지를 확인한 후에 동작하는 조건부 로직이 있다면 특이 케이스 추가하기(10.5)로 필드들이 유효하지 않는 경우를 위한 대안 클래스를 만들어 사용한다.

# 3.17 메시지 체인

메시지 체인은 한 객체를 통해 다른 객체를 얻고 또 얻은 객체에서 또 다른 객체를 요청하는 식이다. 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다. 위임 숨기기(7.7)로 해결한다. 

# 3.18 중개자

객체의 대표적인 기능인 캡슐화가 있다. 캡슐화하는 과정에는 위임이 자주 활용된다. 클래스가 제공하는 메서드 중 절반이 다른 클래서 구현을 위임하고 있다면 중개자 제거하기(7.8)을 사용하여 실제로 일을 하는 객체와 직접 소통하게 한다. 

# 3.19 내부자 거래

모듈사이의 데이터 거래가 많으면 결합도가 높아진다. 함수 옮기기와 필드 옮기기 기법으로 떼어놓아서 사적으로 처리하는 부분을 줄인다. 만약 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 위임숨기기를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.

# 3.20 거대한 클래스

한 클래스가 너무 많은 일을 하면 필드가 늘어나고 필드가 늘어나면 중복 코드가 많아진다. 클래스 추출하기(7.5)로 필드의 일부를 따로 묶는다. 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보이다.

# 3.21 서로 다른 인터페이스의 대안 클래스

# 3.22 데이터 클래스

데이터 클래스란 데이터 필드와 게터 메서드로만 구성된 클래스를 말한다. public 필드가 있다면 레코드 캡슐화하기(7.1)로 숨기고 변경되지 않는 필드는 세터를 제거하여 접근을 막는다.

# 3.23 상속 포기

서브클래스는 부모클래스의 메서드와 데이터를 물려받는다. 하지만 부모의 유산이 필요 없는 경우도 있을 수 있다.

예전에는 계층구조를 잘못 설계했기 때문으로 봤다.

해법은 먼저 같은 ㄱ층에 서브클래스를 하나 새로 만들고, 메서드 내리기와 필드 내리기를 활용하여 부모 코드를 모조리 새로 만든 서브클래스로 넘긴다. 그러면 부모에는 공통 부분만 남는다.

# 3.24 주석

특정 코드 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**

이미 추출이 되어 있는 함수임에도 여전히 설명이 필요하다면 **함수 선언 바꾸기**로 함수 이름을 바꿔본다.

시스템이 동작하기 위한 선행 조건을 명시하고 싶다면 **어서션 추가하기**가 대기하고 있다.